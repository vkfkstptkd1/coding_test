# 문제
# 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 
# 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 
# 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 
# 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

# 입력
# 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 
# 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 
# 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

# 출력
# 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.


# 회의의 수 입력
n = int(input())
# 회의의 정보 입력 ( 회의시작시간  끝나는시간 )
meetings =[list(map(int,input().split())) for _ in range (n)]


# 정답을 위한 핵심 전략
# 1. 회의 끝나는 시간 기준으로 오름차순 정렬
# 2. 매 회의마다 이전 회의가 끝난 시간 이후에 시작하면 선택

# 1. 회의 끝나는 시간 기준으로 오름차순 정렬 & 같을 경우, 시작시간 기준으로 오름차순 정렬
meetings.sort(key=lambda x: (x[1], x[0]))

count =0 
end_time=0
# 원본 배열을 두번째 ~ 끝까지 돌면서 이전 회의가 끝난 시간 이후에 시작하면 선택한다. 
for start,end in meetings:
    # 조건을 만족하면 result에 넣은 후, 해당 시간을 비교할 end_time으로 갱신한다.
    if start >= end_time:
        count+=1
        end_time= end
    

print(count)
# 완전 틀린 알고리즘 20250408
# # 시간은 0 - 23

# # 1. 시작시간이 작은 순서대로 정렬한다.
# # 2. 두 시간 차이가 작은 순서대로 정렬한다.
# meetings.sort(key =lambda x:(x[0],x[1]-x[0]))
# print(meetings)
# # 3. 시작시간이 같은 애들은 첫번째를 제외하고 다 지운다. 
# a = meetings[0][0] # 첫번째 열, 첫번째 행
# new_meeting=[]
# new_meeting.append(meetings[0])

# for i in range (1,n):    
#     # 다음행과 이전행의 시작 시간이 같으면 넘어가라
#     if meetings[i][0] == a:
#         continue
#     # 다음행과 이전행의 시작 시간이 다르면 삽입 후, a를 해당 행으로 변경한다.
#     else:
#         new_meeting.append(meetings[i])
#         a = meetings[i][0]

# # 4. 겹치는 시간을 지우자. 
# # 4-1. 차가 적은 기준으로 정렬 후, 숫자가 작은 것 부터 정렬
# # 4-2 
# count =0 
# sum =0
# for i in range (len(new_meeting)):
#     # 끝시간 - 시작시간을 구한 후 합에다 넣는다.
#     sum += new_meeting[i][1] - new_meeting[i][0]
#     # 카운트를 추가한다.
#     count +=1
# print(count)
